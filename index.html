<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <link rel="icon" type="image/x-icon" href="/img/ico.jpg">
  <title>3D Model Walkthrough with Enhanced Lighting</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #f0f0f0;
      
    }

    #scene-container {
      position: relative;
      width: 100%;
      height: 100%;
    }

    #canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Joystick container */
    #joystick-container {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 100px;
      height: 100px;
      z-index: 100;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #joystick-base {
      width: 100px;
      height: 100px;
      background: rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #joystick-handle {
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      position: absolute;
      touch-action: none;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
      transition: transform 0.1s ease-in-out;
    }

    .cube-face {
      width: 200px;
      height: 200px;
      background-color: rgba(255, 255, 255, 0.9);
      border: 1px solid #cccccc;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: #333333;
    }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
        "three/examples/jsm/loaders/GLTFLoader.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/GLTFLoader.js",
        "three/examples/jsm/loaders/DRACOLoader.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/DRACOLoader.js",
        "three/examples/jsm/renderers/CSS3DRenderer.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/renderers/CSS3DRenderer.js"
      }
    }
  </script>
</head>

<body>
  <div id="scene-container"> 
    <canvas id="canvas"></canvas> 


    <div id="joystick-container">
      <div id="joystick-base">
        <div id="joystick-handle"></div>
      </div>
    </div>
  </div>
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
    import { CSS3DRenderer, CSS3DObject } from 'three/examples/jsm/renderers/CSS3DRenderer.js';

    let camera, scene, renderer, cssRenderer, cssScene;
    const keysPressed = {};
    const moveSpeed = 0.03; // Reduced move speed for smoother control
    let modelBoundingBox;

    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };

    // Joystick variables
    let joystickActive = false;
    let joystickPosition = { x: 0, y: 0 };
    const joystickMaxDistance = 40;

    // Store camera positions for navigation history
    const cameraHistory = [];
    let currentHistoryIndex = -1;
    const MAX_HISTORY = 50;

    // Debounce function for resize events
    function debounce(func, wait) {
      let timeout;
      return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }

    init();
    animate();

    function init() {
      renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('canvas') });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0xaaaaaa);

      cssRenderer = new CSS3DRenderer();
      cssRenderer.setSize(window.innerWidth, window.innerHeight);
      cssRenderer.domElement.style.position = 'absolute';
      cssRenderer.domElement.style.top = '0px';
      document.getElementById('scene-container').appendChild(cssRenderer.domElement);

      scene = new THREE.Scene();
      cssScene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 3);
      camera.rotation.set(0, 0, 0);

      // Lighting setup
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.3);
      dirLight.position.set(5, 10, 7.5);
      scene.add(dirLight);

      const pointLight1 = new THREE.PointLight(0xffffff, 0.3, 50);
      pointLight1.position.set(2, 5, 2);
      scene.add(pointLight1);

      const pointLight2 = new THREE.PointLight(0xffffff, 0.3, 50);
      pointLight2.position.set(-2, 5, -2);
      scene.add(pointLight2);

      const pointLight3 = new THREE.PointLight(0xffffff, 0.3, 50);
      pointLight3.position.set(0, 5, -5);
      scene.add(pointLight3);

      const roofLight = new THREE.SpotLight(0xffffff, 0.5, 30, Math.PI / 4, 0.5);
      roofLight.position.set(0, 10, 0);
      roofLight.target.position.set(0, 1, 0);
      roofLight.target.updateMatrixWorld();
      scene.add(roofLight);
      scene.add(roofLight.target);

      const yellowLight = new THREE.PointLight(0xffff00, 0.2, 50);
      yellowLight.position.set(0, 5, 0);
      scene.add(yellowLight);

      // DRACO loader
      const dracoLoader = new DRACOLoader();
      dracoLoader.setDecoderPath('./draco/');

      const loader = new GLTFLoader();
      loader.setDRACOLoader(dracoLoader);

      loader.load('model.glb',
        (gltf) => {
          const model = gltf.scene;
          model.scale.set(1, 1, 1);
          model.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = false;
              child.receiveShadow = false;
            }
          });
          scene.add(model);

          modelBoundingBox = new THREE.Box3().setFromObject(model);
        },
        undefined,
        (err) => console.error('Error loading model:', err)
      );

      // Create CSS3DObjects for cube faces
      const cubeSize = 200;
      const cubeFaces = [
        { position: [0, cubeSize, 0], rotation: [0, 0, 0] },
        { position: [0, -cubeSize, 0], rotation: [Math.PI, 0, Math.PI] },
        { position: [0, 0, cubeSize], rotation: [0, Math.PI, 0] },
        { position: [0, 0, -cubeSize], rotation: [0, 0, 0] },
        { position: [cubeSize, 0, 0], rotation: [0, Math.PI / 2, 0] },
        { position: [-cubeSize, 0, 0], rotation: [0, -Math.PI / 2, 0] }
      ];

      const faceElements = document.querySelectorAll('.cube-face');
      faceElements.forEach((face, index) => {
        const cssObject = new CSS3DObject(face);
        cssObject.position.set(...cubeFaces[index].position);
        cssObject.rotation.set(...cubeFaces[index].rotation);
        cssScene.add(cssObject);
      });

      // Input event listeners
      document.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        keysPressed[key] = true;

        if (e.altKey && key === 'arrowleft') {
          navigateBack();
          e.preventDefault();
        } else if (e.altKey && key === 'arrowright') {
          navigateForward();
          e.preventDefault();
        }
      });

      document.addEventListener('keyup', (e) => {
        keysPressed[e.key.toLowerCase()] = false;
      });

      document.addEventListener('mousedown', onMouseDown, false);
      document.addEventListener('mouseup', onMouseUp, false);
      document.addEventListener('mousemove', onMouseMove, false);

      // Joystick event listeners
      const joystickHandle = document.getElementById('joystick-handle');
      const joystickBase = document.getElementById('joystick-base');
      const joystickRect = joystickBase.getBoundingClientRect();
      const joystickCenter = {
        x: joystickRect.left + joystickRect.width / 2,
        y: joystickRect.top + joystickRect.height / 2
      };

      function handleJoystickStart(e) {
        joystickActive = true;
        if (e.type === 'touchstart') {
          e.preventDefault();
        }
      }

      function handleJoystickMove(e) {
        if (!joystickActive) return;

        let clientX, clientY;
        if (e.type === 'touchmove') {
          e.preventDefault();
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        } else {
          clientX = e.clientX;
          clientY = e.clientY;
        }

        // Calculate joystick position relative to center
        const deltaX = clientX - joystickCenter.x;
        const deltaY = clientY - joystickCenter.y;

        // Limit joystick to max distance
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const angle = Math.atan2(deltaY, deltaX);

        const limitedDistance = Math.min(distance, joystickMaxDistance);
        joystickPosition.x = Math.cos(angle) * limitedDistance;
        joystickPosition.y = Math.sin(angle) * limitedDistance;

        // Update joystick handle position
        joystickHandle.style.transform = `translate(${joystickPosition.x}px, ${joystickPosition.y}px)`;
      }

      function handleJoystickEnd() {
        joystickActive = false;
        joystickPosition.x = 0;
        joystickPosition.y = 0;
        joystickHandle.style.transform = 'translate(-50%, -50%)';
      }

      // Mouse events
      joystickHandle.addEventListener('mousedown', handleJoystickStart);
      document.addEventListener('mousemove', handleJoystickMove);
      document.addEventListener('mouseup', handleJoystickEnd);

      // Touch events
      joystickHandle.addEventListener('touchstart', handleJoystickStart);
      document.addEventListener('touchmove', handleJoystickMove);
      document.addEventListener('touchend', handleJoystickEnd);

      // Debounced resize event
      window.addEventListener('resize', debounce(() => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        cssRenderer.setSize(window.innerWidth, window.innerHeight);
      }, 200));

      saveCameraState();
    }

    function saveCameraState() {
      if (currentHistoryIndex >= 0) {
        const lastState = cameraHistory[currentHistoryIndex];
        if (lastState &&
          lastState.position.equals(camera.position) &&
          lastState.rotation.equals(camera.rotation)) {
          return;
        }
      }

      if (currentHistoryIndex < cameraHistory.length - 1) {
        cameraHistory.splice(currentHistoryIndex + 1);
      }

      cameraHistory.push({
        position: camera.position.clone(),
        rotation: camera.rotation.clone()
      });

      if (cameraHistory.length > MAX_HISTORY) {
        cameraHistory.shift();
      } else {
        currentHistoryIndex = cameraHistory.length - 1;
      }
    }

    function navigateBack() {
      if (currentHistoryIndex > 0) {
        currentHistoryIndex--;
        restoreCameraState();
      }
    }

    function navigateForward() {
      if (currentHistoryIndex < cameraHistory.length - 1) {
        currentHistoryIndex++;
        restoreCameraState();
      }
    }

    function restoreCameraState() {
      const state = cameraHistory[currentHistoryIndex];
      if (state) {
        camera.position.copy(state.position);
        camera.rotation.copy(state.rotation);
      }
    }

    function onMouseDown(event) {
      isDragging = true;
      previousMousePosition = {
        x: event.clientX,
        y: event.clientY
      };
    }

    function onMouseUp() {
      isDragging = false;
      saveCameraState();
    }

    function onMouseMove(event) {
      if (!isDragging) return;

      const deltaX = event.clientX - previousMousePosition.x;
      const deltaY = event.clientY - previousMousePosition.y;

      camera.rotation.y -= deltaX * 0.005;
      camera.rotation.x -= deltaY * 0.005;

      camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

      previousMousePosition = {
        x: event.clientX,
        y: event.clientY
      };
    }

    function animate() {
      requestAnimationFrame(animate);

      const direction = new THREE.Vector3();

      // Keyboard controls
      if (keysPressed['w'] || keysPressed['arrowup']) direction.z -= moveSpeed;
      if (keysPressed['s'] || keysPressed['arrowdown']) direction.z += moveSpeed;
      if (keysPressed['a'] || keysPressed['arrowleft']) direction.x -= moveSpeed;
      if (keysPressed['d'] || keysPressed['arrowright']) direction.x += moveSpeed;

      // Joystick controls
      if (joystickActive) {
        // Right/left movement (x-axis)
        direction.x += (joystickPosition.x / joystickMaxDistance) * moveSpeed * 2;
        // Forward/backward movement (z-axis)
        direction.z -= (joystickPosition.y / joystickMaxDistance) * moveSpeed * 2;
      }

      const cameraDirection = new THREE.Vector3();
      camera.getWorldDirection(cameraDirection);

      const right = new THREE.Vector3();
      camera.getWorldDirection(cameraDirection);
      right.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0));

      camera.position.add(cameraDirection.multiplyScalar(-direction.z));
      camera.position.add(right.multiplyScalar(direction.x));
      camera.position.y = 1.6;

      if (modelBoundingBox) {
        const padding = 1;
        camera.position.x = Math.max(modelBoundingBox.min.x + padding, Math.min(camera.position.x, modelBoundingBox.max.x - padding));
        camera.position.z = Math.max(modelBoundingBox.min.z + padding, Math.min(camera.position.z, modelBoundingBox.max.z - padding));
      }

      renderer.render(scene, camera);
      cssRenderer.render(cssScene, camera);
    }
  </script>
</body>

</html>


