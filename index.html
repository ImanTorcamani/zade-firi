<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <link rel="icon" type="image/x-icon" href="/img/ico.jpg">
  <title>3D Model Animation with Ray Tracing</title>

  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      width: 100%;
      background-color: #f0f0f0;
    }

    #canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #joystick-container {
      position: absolute;
      top: 10%;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      pointer-events: none;
    }

    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-family: Arial, sans-serif;
      font-size: 24px;
    }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
        "three/examples/jsm/loaders/GLTFLoader.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/GLTFLoader.js",
        "three/examples/jsm/loaders/DRACOLoader.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/DRACOLoader.js",
        "three/examples/jsm/postprocessing/EffectComposer.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/EffectComposer.js",
        "three/examples/jsm/postprocessing/RenderPass.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/RenderPass.js",
        "three/examples/jsm/postprocessing/ShaderPass.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/ShaderPass.js",
        "three/examples/jsm/shaders/CopyShader.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/shaders/CopyShader.js",
        "three/examples/jsm/shaders/LuminosityHighPassShader.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/shaders/LuminosityHighPassShader.js",
        "three/examples/jsm/postprocessing/UnrealBloomPass.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/UnrealBloomPass.js"
      }
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.8.0/dist/nipplejs.min.js"></script>
</head>

<body>
  <canvas id="canvas"></canvas>
  <div id="joystick-container"></div>
  <div id="loading">Loading...</div>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
    import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
    import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
    import { CopyShader } from 'three/examples/jsm/shaders/CopyShader.js';
    import { LuminosityHighPassShader } from 'three/examples/jsm/shaders/LuminosityHighPassShader.js';
    import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

    let camera, scene, renderer, mixer, composer;
    let animationPlayed = false;
    let animatedObject = null;
    let modelBoundingBox;
    const keysPressed = {};
    const moveSpeed = 0.03;
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let rotationY = 0;

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let joystick;
    let pointLight;
    let bloomPass;

    function init() {
      const canvas = document.getElementById('canvas');
      renderer = new THREE.WebGLRenderer({ 
        canvas, 
        antialias: true,
        powerPreference: "high-performance"
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.physicallyCorrectLights = true;
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      renderer.useLegacyLights = false;

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, -0.7);

      // Enhanced lighting setup for ray-traced look
      const ambientLight = new THREE.AmbientLight(0x7ec8e3, 1);
      scene.add(ambientLight);

      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 3);
      hemiLight.position.set(0, 2, -2);
      scene.add(hemiLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
      directionalLight.position.set(0, 10, 0);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048; // Higher resolution for better shadows
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 1;
      directionalLight.shadow.camera.far = 50;
      directionalLight.shadow.bias = -0.001; // Reduce shadow acne
      scene.add(directionalLight);

      // Add a subtle fill light
      const fillLight = new THREE.DirectionalLight(0x7ec8e3, 0.5);
      fillLight.position.set(-5, 5, 5);
      scene.add(fillLight);

      // Setup post-processing for bloom/glow effects
      const renderScene = new RenderPass(scene, camera);
      bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.5, // strength
        0.4, // radius
        0.85 // threshold
      );

      composer = new EffectComposer(renderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);

      const dracoLoader = new DRACOLoader();
      dracoLoader.setDecoderPath('./draco/');
      const modelLoader = new GLTFLoader();
      modelLoader.setDRACOLoader(dracoLoader);

      modelLoader.load('model.glb', (gltf) => {
        document.getElementById('loading').style.display = 'none';
        
        const model = gltf.scene;
        model.traverse(child => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            
            // Enhance materials for better lighting response
            if (child.material) {
              child.material.roughness = 0.1;
              child.material.metalness = 0.9;
              child.material.envMapIntensity = 0.5;
            }
          }
        });
        scene.add(model);

        modelBoundingBox = new THREE.Box3().setFromObject(model).expandByScalar(-0.7);

        animatedObject = model.getObjectByName("Animated");
        const lightObject = model.getObjectByName("Light");

        if (!animatedObject || !lightObject) {
          console.error("Animated object or Light object not found in the model.");
          return;
        }

        // Create and position the point light with enhanced settings
        pointLight = new THREE.PointLight(0xffffff, 5, 15, 2);
        pointLight.position.copy(lightObject.position);
        pointLight.castShadow = true;
        pointLight.shadow.mapSize.width = 1024;
        pointLight.shadow.mapSize.height = 1024;
        pointLight.shadow.bias = -0.001;
        scene.add(pointLight);

        // Add light helper (for debugging)
        // const lightHelper = new THREE.PointLightHelper(pointLight);
        // scene.add(lightHelper);

        mixer = new THREE.AnimationMixer(animatedObject);
        const action = mixer.clipAction(gltf.animations.find(anim => anim.name === 'animation'));
        action.clampWhenFinished = true;
        action.loop = THREE.LoopOnce;

        mixer.addEventListener('finished', () => {
          console.log('Animation finished');
          animationPlayed = false;
        });
      }, undefined, (err) => console.error('Error loading model:', err));

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });

      window.addEventListener('click', (event) => {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        if (animatedObject) {
          const intersects = raycaster.intersectObject(animatedObject, true);
          if (intersects.length > 0 && !animationPlayed) {
            const action = mixer.clipAction(mixer._actions[0]._clip);
            action.reset().play();
            animationPlayed = true;
            action.paused = false;
          }
        }
      });

      if (window.innerWidth <= 800) {
        joystick = nipplejs.create({
          zone: document.getElementById('joystick-container'),
          mode: 'static',
          position: { left: '50%', top: '50%' },
          color: 'blue',
          size: 150,
        });

        joystick.on('move', (evt, data) => {
          const moveDirection = new THREE.Vector3();
          moveDirection.x = data.vector.x * moveSpeed;
          moveDirection.z = -data.vector.y * moveSpeed;

          const camDir = new THREE.Vector3();
          camera.getWorldDirection(camDir);
          camDir.y = 0;
          camDir.normalize();

          const right = new THREE.Vector3();
          right.crossVectors(camDir, new THREE.Vector3(0, 1, 0)).normalize();

          const newPos = camera.position.clone();
          newPos.add(camDir.multiplyScalar(-moveDirection.z));
          newPos.add(right.multiplyScalar(moveDirection.x));

          if (modelBoundingBox && modelBoundingBox.containsPoint(newPos)) {
            camera.position.copy(newPos);
          }
        });
      }

      let touchStart = { x: 0, y: 0 };

      window.addEventListener('touchstart', (event) => {
        touchStart.x = event.touches[0].clientX;
        touchStart.y = event.touches[0].clientY;
      });

      window.addEventListener('touchmove', (event) => {
        if (event.touches.length == 1) {
          const deltaX = event.touches[0].clientX - touchStart.x;
          rotationY += deltaX * 0.005;
          camera.rotation.y = rotationY;
        }
      });

      document.addEventListener('keydown', (e) => {
        keysPressed[e.key.toLowerCase()] = true;
      });

      document.addEventListener('keyup', (e) => {
        keysPressed[e.key.toLowerCase()] = false;
      });

      document.addEventListener('mousedown', (event) => {
        isDragging = true;
        previousMousePosition = { x: event.clientX, y: event.clientY };
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
      });

      document.addEventListener('mousemove', (event) => {
        if (isDragging) {
          const deltaX = event.clientX - previousMousePosition.x;
          rotationY += deltaX * 0.01;
          camera.rotation.y = rotationY;
          previousMousePosition = { x: event.clientX, y: event.clientY };
        }
      });

      animate();
    }

    function animate() {
      requestAnimationFrame(animate);
      if (mixer) mixer.update(0.01);

      // Update the light position only if objects exist
      if (animatedObject && pointLight) {
        const lightObject = animatedObject.getObjectByName("Light");
        if (lightObject) {
          pointLight.position.copy(lightObject.position);
        }
      }

      const moveDirection = new THREE.Vector3();
      if (keysPressed['w'] || keysPressed['arrowup']) moveDirection.z -= moveSpeed;
      if (keysPressed['s'] || keysPressed['arrowdown']) moveDirection.z += moveSpeed;
      if (keysPressed['a'] || keysPressed['arrowleft']) moveDirection.x -= moveSpeed;
      if (keysPressed['d'] || keysPressed['arrowright']) moveDirection.x += moveSpeed;

      const camDir = new THREE.Vector3();
      camera.getWorldDirection(camDir);
      camDir.y = 0;
      camDir.normalize();

      const right = new THREE.Vector3();
      right.crossVectors(camDir, new THREE.Vector3(0, 1, 0)).normalize();

      const newPos = camera.position.clone();
      newPos.add(camDir.multiplyScalar(-moveDirection.z));
      newPos.add(right.multiplyScalar(moveDirection.x));

      if (modelBoundingBox && modelBoundingBox.containsPoint(newPos)) {
        camera.position.copy(newPos);
      }

      // Render with post-processing
      composer.render();
    }

    init();
  </script>
</body>

</html>